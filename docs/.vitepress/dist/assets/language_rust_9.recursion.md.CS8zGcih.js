import{_ as n,c as a,a0 as p,o as e}from"./chunks/framework.DOEc3Y8C.js";const u=JSON.parse('{"title":"recursion","description":"","frontmatter":{},"headers":[],"relativePath":"language/rust/9.recursion.md","filePath":"language/rust/9.recursion.md"}'),t={name:"language/rust/9.recursion.md"};function l(i,s,o,c,d,g){return e(),a("div",null,s[0]||(s[0]=[p(`<h1 id="recursion" tabindex="-1">recursion <a class="header-anchor" href="#recursion" aria-label="Permalink to &quot;recursion&quot;">​</a></h1><p><strong>递归</strong></p><p>在 Rust 中，递归类型指的是一个类型的定义中直接或间接地引用了自身。这样的定义在许多数据结构，如树和链表中是很常见的。</p><p>但在 Rust 中，由于所有权和生命周期的规则，直接定义递归类型需要一些额外的注意。</p><p><strong>链表</strong></p><p>链表是一个常见的递归数据结构。考虑以下简单的单向链表定义：</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>enum List&lt;T&gt; {</span></span>
<span class="line"><span>    Cons(T, Box&lt;List&lt;T&gt;&gt;),</span></span>
<span class="line"><span>    Nil,</span></span>
<span class="line"><span>}</span></span></code></pre></div><p>这是一个泛型枚举 <code>List&lt;T&gt;</code>，它有两个变体：<code>Cons</code> 和 <code>Nil</code>。</p><p><strong>Cons 变体：</strong></p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>Cons(T, Box&lt;List&lt;T&gt;&gt;)</span></span></code></pre></div><p>这个变体代表链表中的一个节点。它有两部分：</p><ul><li><code>T</code>: 这是链表节点存储的实际数据的类型。</li><li><code>Box&lt;List&lt;T&gt;&gt;</code>: 这是一个指向链表中的下一个节点的指针。</li></ul><p>在这里，使用 <code>Box</code> 是为了使递归数据结构在 Rust 中工作。由于 Rust 的所有数据类型都必须有一个已知的固定大小，我们不能直接在 <code>Cons</code> 变体中嵌套 <code>List&lt;T&gt;</code>，因为这会导致其大小无限制。使用 <code>Box</code> 解决了这个问题，因为 <code>Box</code> 是一个固定大小的堆分配指针。</p><p><strong>Nil 变体：</strong></p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>Nil</span></span></code></pre></div><p>这个变体代表链表的结束。当你到达链表的最后一个节点时，该节点的指针会指向 <code>Nil</code>。</p><p><strong>总体分析：</strong></p><p>这个 <code>List</code> 的定义表示一个单向链表，其中：</p><ul><li>每个节点包含一个值和一个指向下一个节点的指针。</li><li>链表的结束由 <code>Nil</code> 表示。</li></ul><p>例如，一个包含整数 1、2 和 3 的链表可以表示为：</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>Cons(1, Box::new(Cons(2, Box::new(Cons(3, Box::new(Nil))))))</span></span></code></pre></div><p>这种表示方法非常简洁，并完全利用了 Rust 的类型系统和所有权模型来创建一个安全、高效的链表实现。</p><p><strong>单向链表</strong></p><p>单向链表中的每个节点都有一个值和一个指向下一个节点的指针。这里是一个简单的单向链表实现：</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>enum Node&lt;T&gt; {</span></span>
<span class="line"><span>    Cons(T, Box&lt;Node&lt;T&gt;&gt;),</span></span>
<span class="line"><span>    Nil,</span></span>
<span class="line"><span>}</span></span>
<span class="line"><span>​</span></span>
<span class="line"><span>struct LinkedList&lt;T&gt; {</span></span>
<span class="line"><span>    head: Node&lt;T&gt;,</span></span>
<span class="line"><span>}</span></span></code></pre></div><p>在这个定义中：</p><p>Node 是一个枚举，有两个变体：Cons 和 Nil。 Cons 变体包含一个值和一个指向下一个节点的 Box&lt;Node&lt; T&gt;&gt;。 使用 Box 是因为 Rust 的类型需要一个固定的大小，而 Box 提供了一个固定大小的指针，实际数据存储在堆上。</p><p>一般来说，这个代码在上面那一部分结束之后就算是链表结束了，但是为什么我们还要写后面的那一堆东西呢？那一堆东西是干什么的？</p><p>通常我们还会添加一个 struct（如 LinkedList&lt;T&gt;）来表示整个链表，主要有以下几个原因：</p><ol><li>更清晰的语义 有了 LinkedList 这样的结构体，我们可以更清晰地表示这是一个链表的开始（或头部）。这样，当我们看到 LinkedList 类型时，就能立刻知道这是整个链表，而不仅仅是其中的一个节点。</li><li>扩展性 使用 struct 表示整个链表可以让我们在未来更容易地添加更多的字段或方法。例如，我们可能希望在 LinkedList 结构体中添加一个 tail 字段来快速访问链表的尾部，或者添加一个 length 字段来存储链表的长度。</li><li>方法的实现 在 Rust 中，我们可以为 struct 实现方法。通过这种方式，我们可以为 LinkedList 实现一些常见的链表操作，如 append, pop, push 等。</li></ol><p>例如：</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>impl&lt;T&gt; LinkedList&lt;T&gt; {</span></span>
<span class="line"><span>    fn new() -&gt; Self {</span></span>
<span class="line"><span>        LinkedList { head: Nil }</span></span>
<span class="line"><span>    }  </span></span>
<span class="line"><span>// 其他方法...</span></span>
<span class="line"><span>}</span></span></code></pre></div><p>尽管 enum Node&lt;T&gt; { Cons(T, Box&lt;Node&lt;T&gt;&gt;), Nil } 本身就是一个链表的定义，但使用额外的 struct 来表示整个链表可以为我们提供更多的灵活性、清晰性和扩展性。</p><p><strong>双向链表</strong></p><p>双向链表与单向链表类似，但每个节点还有一个指向前一个节点的指针。这使得从链表的任何位置开始向前遍历成为可能。</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>struct DoubleNode&lt;T&gt; {</span></span>
<span class="line"><span>    value: T,</span></span>
<span class="line"><span>    next: Option&lt;Box&lt;DoubleNode&lt;T&gt;&gt;&gt;,</span></span>
<span class="line"><span>    prev: Option&lt;*mut DoubleNode&lt;T&gt;&gt;,  // 使用裸指针，因为 Rust 不允许双向所有权</span></span>
<span class="line"><span>}</span></span>
<span class="line"><span>​</span></span>
<span class="line"><span>struct DoublyLinkedList&lt;T&gt; {</span></span>
<span class="line"><span>    head: Option&lt;Box&lt;DoubleNode&lt;T&gt;&gt;&gt;,</span></span>
<span class="line"><span>    tail: Option&lt;*mut DoubleNode&lt;T&gt;&gt;,</span></span>
<span class="line"><span>}</span></span>
<span class="line"><span>​</span></span></code></pre></div><p><strong>使用链表</strong></p><p>链表是动态数据结构，它在插入和删除时很有用，因为这些操作通常是 O(1) 的。但在查找和随机访问时，它们比数组和向量慢，因为这些操作是 O(n) 的。</p><p>Rust 标准库的 LinkedList Rust 的标准库提供了一个现成的 LinkedList 实现，它是一个双向链表。你可以使用 std::collections::LinkedList 而不是自己实现。</p><p><strong>Box介绍</strong></p><p>在 Rust 中，<code>Box&lt;T&gt;</code> 是一个非常重要的类型，它代表一个在堆上分配的值。以下是有关 <code>Box&lt;T&gt;</code> 的详细介绍：</p><p><strong>基本概念</strong></p><ul><li><strong>堆分配</strong>：Rust 中的默认行为是在栈上分配数据。栈上的数据有固定的大小，生命周期短，且在其作用域结束时自动清理。然而，有时我们需要在堆上分配数据，这样的数据可以在运行时动态地改变大小，并且其生命周期不受作用域的限制。</li><li><strong>Box</strong>：<code>Box&lt;T&gt;</code> 是一个智能指针，它指向堆上分配的 <code>T</code> 类型的数据。当 <code>Box</code> 离开作用域时，它的析构函数会被调用，从而释放堆上的数据，确保没有内存泄漏。</li></ul><p><em>当 Box&lt;T&gt; 离开其作用域时，以下操作会发生：</em></p><p><em>Box&lt;T&gt; 的 drop 方法被调用。</em> <em>该方法会释放 Box 指向的堆内存。</em> <em>如果 T 也实现了 Drop trait，那么 T 的 drop 方法也会被调用，确保任何需要的清理操作都已完成。</em></p><p><strong>用途</strong></p><ul><li><p><strong>递归类型</strong>：由于 Rust 需要知道每种类型的确切大小，因此直接定义递归类型（例如链表和树）是不可能的。使用 <code>Box</code> 可以解决这个问题，因为 <code>Box</code> 的大小是固定的，不管它指向的数据有多大。</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>enum List&lt;T&gt; {</span></span>
<span class="line"><span>    Cons(T, Box&lt;List&lt;T&gt;&gt;),</span></span>
<span class="line"><span>    Nil,</span></span>
<span class="line"><span>}</span></span></code></pre></div></li><li><p><strong>大型数据</strong>：如果数据非常大，而你不希望它占用栈空间，你可以使用 <code>Box</code> 将它移动到堆上。</p></li><li><p><strong>所有权转移</strong>：<code>Box</code> 可以用来表示一个数据的唯一所有权，并将这个所有权转移到其他函数或线程。</p></li></ul><p><strong>使用</strong></p><p>创建一个 <code>Box</code>：</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>let b = Box::new(5);  // b 的类型是 Box&lt;i32&gt;</span></span></code></pre></div><p><strong>解引用：</strong></p><p>解引用是一个操作，它允许你访问指针或引用所指向的真实数据。在编程中，当我们使用指针或引用来指向某个数据时，有时我们需要直接操作或访问这个数据，而不是操作指针或引用本身。这就需要用到解引用。</p><p>由于 <code>Box&lt;T&gt;</code> 实现了 <code>Deref</code> trait，你可以使用 <code>*</code> 运算符来访问其内部的数据：</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>let b = Box::new(5);</span></span>
<span class="line"><span>assert_eq!(*b, 5);</span></span></code></pre></div><p><strong>性能</strong></p><ul><li><strong>运行时成本</strong>：虽然 <code>Box</code> 本身的开销很小，但在堆上分配和释放数据会有一些运行时成本。因此，对于小型数据或短暂存在的数据，通常更倾向于在栈上分配。</li><li><strong>空间开销</strong>：<code>Box</code> 本身只是一个指针的大小，但它指向的数据是在堆上分配的，所以实际的空间使用量取决于数据的大小。</li></ul><p><strong>总结</strong></p><p><code>Box&lt;T&gt;</code> 在 Rust 中是一个非常有用的工具，允许开发者在堆上分配数据，并为其提供自动的内存管理。它在处理大型数据、递归数据结构或需要转移所有权的情况下特别有用。</p><p><strong>方法</strong></p><p>在 Rust 中，方法是定义在某种数据结构上的函数，通常这些数据结构是结构体 (struct)、枚举 (enum) 或特性 (trait)。方法与普通函数的区别在于，方法始终与某个数据类型相关联，并且在其签名中有一个额外的第一个参数，通常是 self，代表其调用者。</p><p>定义和调用方法： 方法定义在 impl 块中，这个块为一个特定的数据类型提供方法实现。</p><p>例如，定义一个 Rectangle 结构体和一个方法来计算其面积：</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>struct Rectangle {</span></span>
<span class="line"><span>    width: u32,</span></span>
<span class="line"><span>    height: u32,</span></span>
<span class="line"><span>}</span></span>
<span class="line"><span>​</span></span>
<span class="line"><span>impl Rectangle {</span></span>
<span class="line"><span>    fn area(&amp;self) -&gt; u32 {</span></span>
<span class="line"><span>        self.width * self.height</span></span>
<span class="line"><span>    }</span></span>
<span class="line"><span>}</span></span>
<span class="line"><span>​</span></span>
<span class="line"><span>// 使用方法</span></span>
<span class="line"><span>let rect = Rectangle { width: 30, height: 50 };</span></span>
<span class="line"><span>println!(&quot;The area of the rectangle is {} square pixels.&quot;, rect.area());</span></span></code></pre></div><p>在上述示例中：</p><p>area 方法定义在 Rectangle 结构体的 impl 块中。 该方法接受一个名为 self 的参数，它是一个 &amp;Rectangle 类型的引用，表示方法的调用者。 调用方法时，使用 . 符号，如 rect.area()。</p><p><br><strong>方法和所有权</strong></p><p><strong>self 参数的几种形式：</strong></p><p>引用 (&amp;self): 这是只读方法，不会修改调用者。 可变引用 (&amp;mut self): 这允许方法修改其调用者。 所有权 (self): 这允许方法消费或转移调用者的所有权。 关联函数： 除了方法，impl 块还可以包含不取 self 为参数的函数，这些函数被称为关联函数。最常见的关联函数是 new，用于创建结构体的新实例。</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>impl Rectangle {</span></span>
<span class="line"><span>    fn square(size: u32) -&gt; Rectangle {</span></span>
<span class="line"><span>        Rectangle { width: size, height: size }</span></span>
<span class="line"><span>    }</span></span>
<span class="line"><span>}</span></span>
<span class="line"><span>let sq = Rectangle::square(20);</span></span>
<span class="line"><span>​</span></span></code></pre></div><p>在这个例子中，square 是一个关联函数，用于创建一个正方形 Rectangle。</p><p><strong>关联函数</strong></p><p>关联函数是定义在结构体、枚举或特性的 <code>impl</code> 块中的函数，但它们不接受 <code>self</code> 作为参数。</p><p>因为它们不作用于一个实例，所以它们也被称为“静态方法”或“类方法”。</p><p>关联函数通常用于：</p><ol><li>创建和返回一个新的实例，例如构造函数。</li><li>提供不需要访问特定实例的功能。</li></ol><p><strong>示例：</strong></p><p>考虑一个 <code>Rectangle</code> 结构体，我们可以有一个关联函数来创建一个正方形，因为正方形是一个特殊的矩形，其中宽度和高度是相等的。</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>struct Rectangle {</span></span>
<span class="line"><span>    width: u32,</span></span>
<span class="line"><span>    height: u32,</span></span>
<span class="line"><span>}</span></span>
<span class="line"><span>​</span></span>
<span class="line"><span>impl Rectangle {</span></span>
<span class="line"><span>    // 关联函数</span></span>
<span class="line"><span>    fn square(size: u32) -&gt; Rectangle {</span></span>
<span class="line"><span>        Rectangle { width: size, height: size }</span></span>
<span class="line"><span>    }</span></span>
<span class="line"><span>}</span></span>
<span class="line"><span>​</span></span>
<span class="line"><span>// 使用关联函数</span></span>
<span class="line"><span>let sq = Rectangle::square(10);</span></span></code></pre></div><p>在这个例子中，<code>square</code> 是一个关联函数，它接受一个 <code>u32</code> 参数并返回一个 <code>Rectangle</code> 实例。注意我们是如何使用 <code>::</code> 而不是 <code>.</code> 来调用关联函数的。这是因为它不是在一个 <code>Rectangle</code> 实例上调用的，而是直接在 <code>Rectangle</code> 类型上调用的。</p>`,79)]))}const h=n(t,[["render",l]]);export{u as __pageData,h as default};
