import{_ as a,c as n,a0 as e,o as p}from"./chunks/framework.DDvRCNFD.js";const g=JSON.parse('{"title":"Vector and type conversion","description":"","frontmatter":{},"headers":[],"relativePath":"language/rust/4.vector-and-type-conversion.md","filePath":"language/rust/4.vector-and-type-conversion.md"}'),o={name:"language/rust/4.vector-and-type-conversion.md"};function t(l,s,c,i,d,r){return p(),n("div",null,s[0]||(s[0]=[e(`<h1 id="vector-and-type-conversion" tabindex="-1">Vector and type conversion <a class="header-anchor" href="#vector-and-type-conversion" aria-label="Permalink to &quot;Vector and type conversion&quot;">​</a></h1><p><strong>向量和类型转换</strong></p><h4 id="向量" tabindex="-1">向量 <a class="header-anchor" href="#向量" aria-label="Permalink to &quot;向量&quot;">​</a></h4><p>在 Rust 中，向量（Vector）是一种存储多个值的动态数组或列表。与数组不同，向量的大小是可以变化的，这意味着你可以在运行时向向量中添加或删除元素。</p><p>向量是 Rust 的标准库 <code>std::vec::Vec</code> 提供的一种数据结构。</p><p>以下是关于 Rust 中向量的一些关键点：</p><ol><li><strong>动态大小</strong>：与固定大小的数组不同，向量的大小是动态的。这意味着你可以在运行时添加或删除元素。</li><li><strong>同一类型的元素</strong>：向量中的所有元素都必须是相同的类型。</li><li><strong>内存分配</strong>：向量的元素存储在堆上，这允许它在运行时动态地改变大小。</li><li><strong>常用方法</strong>：向量提供了许多方法来操作其内容，例如 <code>push</code>（添加元素到向量的末尾）、<code>pop</code>（从向量的末尾删除元素）和 <code>len</code>（获取向量的长度）等。</li></ol><p>以下是一个简单的例子，展示如何在 Rust 中使用向量：</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>// 创建一个新的空向量</span></span>
<span class="line"><span>let mut numbers = Vec::new();</span></span>
<span class="line"><span>​</span></span>
<span class="line"><span>// 使用 push 方法向向量中添加元素</span></span>
<span class="line"><span>numbers.push(1);</span></span>
<span class="line"><span>numbers.push(2);</span></span>
<span class="line"><span>numbers.push(3);</span></span>
<span class="line"><span>​</span></span>
<span class="line"><span>// 访问向量中的元素</span></span>
<span class="line"><span>let first_number = numbers[0]; // 1</span></span>
<span class="line"><span>​</span></span>
<span class="line"><span>// 使用 pop 方法从向量的末尾删除元素</span></span>
<span class="line"><span>numbers.pop(); // 删除了 3</span></span>
<span class="line"><span>​</span></span>
<span class="line"><span>// 使用 len 方法获取向量的长度</span></span>
<span class="line"><span>let length = numbers.len(); // 2</span></span></code></pre></div><ul><li>标准库提供的类型，可以直接使用，Vec是分配在堆上的，可增长的数组</li></ul><p>类似c++中的 std::vector, java中的java.util.ArrayList</p><ul><li><p>&lt;T&gt;表示泛型，使用时代入实际的类型，例如：元素是i32类型的Vec写作Vec&lt;i32&gt;</p></li><li><p>使用Vec::new()或vec!宏来创建Vec</p><p>Vec::new()是名字空间的例子，new是定义在Vec结构体中的函数</p></li></ul><h4 id="类型转换" tabindex="-1">类型转换 <a class="header-anchor" href="#类型转换" aria-label="Permalink to &quot;类型转换&quot;">​</a></h4><p>用as进行类型转换（cast）：</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>let x:i32 = 100;</span></span>
<span class="line"><span>let y:u32 = x as u32;</span></span></code></pre></div><p>这段代码展示了 Rust 中的类型转换操作。具体来说，它涉及到从一个类型（<code>i32</code>，32位有符号整数）转换到另一个类型（<code>u32</code>，32位无符号整数）。</p><p>以下是代码的逐步解释：</p><ol><li><code>let x: i32 = 100;</code> 这行代码定义了一个名为 <code>x</code> 的变量，类型为 <code>i32</code>（32位有符号整数），并将其初始化为 <code>100</code>。</li><li><code>let y: u32 = x as u32;</code> 这行代码进行了几个操作： <ul><li>它定义了一个名为 <code>y</code> 的变量，类型为 <code>u32</code>（32位无符号整数）。</li><li>使用 <code>as</code> 关键字进行类型转换，将 <code>x</code>（类型为 <code>i32</code>）的值转换为 <code>u32</code> 类型。</li><li>将转换后的值赋给 <code>y</code>。</li></ul></li></ol><p>因此，经过这两行代码后，你会得到两个变量：<code>x</code> 的类型为 <code>i32</code>，值为 <code>100</code>；<code>y</code> 的类型为 <code>u32</code>，值也为 <code>100</code>。</p><p>需要注意的是，使用 <code>as</code> 进行类型转换可能会有风险，特别是当转换的值超出目标类型的范围时。但在这个特定的例子中，转换是安全的，因为 <code>100</code> 是 <code>i32</code> 和 <code>u32</code> 都可以表示的值</p><p>在 Rust 中，类型转换是一个非常受限制的操作，因为 Rust 高度重视类型安全。不像一些其他语言可以随意地在不同类型之间进行转换，Rust 需要明确的转换。</p><p>以下是 Rust 中一些常见的类型转换方法：</p><ol><li><p><strong>基本类型之间的转换</strong>： 使用 <code>as</code> 关键字可以在基本数值类型之间进行转换：</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>let i = 42;</span></span>
<span class="line"><span>let f = i as f64;</span></span></code></pre></div></li><li><p><strong>字符串到数字</strong>： 使用 <code>parse</code> 方法将字符串转换为数字：</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>let s = &quot;42&quot;;</span></span>
<span class="line"><span>let i: i32 = s.parse().expect(&quot;Not a valid number&quot;);</span></span></code></pre></div></li><li><p><strong>数字到字符串</strong>： 使用 <code>to_string</code> 方法将数字转换为字符串：</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>let i = 42;</span></span>
<span class="line"><span>let s = i.to_string();</span></span></code></pre></div></li><li><p><strong>引用和原始指针之间的转换</strong>：</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>let s = &quot;hello&quot;;</span></span>
<span class="line"><span>let p: *const str = s as *const str;</span></span>
<span class="line"><span>let r: &amp;str = unsafe { &amp;*p };</span></span></code></pre></div></li><li><p><strong><code>From</code> 和 <code>Into</code> trait</strong>： Rust 提供了 <code>From</code> 和 <code>Into</code> 两个 trait 来帮助进行更复杂的类型转换。当你为一个类型实现了 <code>From</code> trait，你同时也获得了 <code>Into</code> trait 的实现。</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>impl From&lt;Foo&gt; for Bar {</span></span>
<span class="line"><span>    fn from(foo: Foo) -&gt; Self {</span></span>
<span class="line"><span>        // ... convert from Foo to Bar</span></span>
<span class="line"><span>    }</span></span>
<span class="line"><span>}</span></span>
<span class="line"><span>​</span></span>
<span class="line"><span>let foo = Foo { /* ... */ };</span></span>
<span class="line"><span>let bar: Bar = foo.into();</span></span></code></pre></div></li><li><p><strong><code>TryFrom</code> 和 <code>TryInto</code> trait</strong>： 对于可能失败的转换，可以使用 <code>TryFrom</code> 和 <code>TryInto</code> trait。它们的方法返回一个 <code>Result</code>。</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>rustCopy codeuse std::convert::TryFrom;</span></span>
<span class="line"><span>​</span></span>
<span class="line"><span>impl TryFrom&lt;Foo&gt; for Bar {</span></span>
<span class="line"><span>    type Error = SomeError;</span></span>
<span class="line"><span>    </span></span>
<span class="line"><span>    fn try_from(foo: Foo) -&gt; Result&lt;Self, Self::Error&gt; {</span></span>
<span class="line"><span>        // ... attempt to convert from Foo to Bar</span></span>
<span class="line"><span>    }</span></span>
<span class="line"><span>}</span></span></code></pre></div></li></ol><p>在进行类型转换时，总是需要小心并确保转换是安全的。尤其是当使用 <code>as</code> 关键字时，因为它可能会进行不安全的转换，如整数溢出或裁剪。</p>`,24)]))}const h=a(o,[["render",t]]);export{g as __pageData,h as default};
