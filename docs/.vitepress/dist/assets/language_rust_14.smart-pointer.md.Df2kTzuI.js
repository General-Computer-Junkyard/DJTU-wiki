import{_ as n,c as a,a0 as e,o as p}from"./chunks/framework.DDvRCNFD.js";const u=JSON.parse('{"title":"smart pointer","description":"","frontmatter":{},"headers":[],"relativePath":"language/rust/14.smart-pointer.md","filePath":"language/rust/14.smart-pointer.md"}'),t={name:"language/rust/14.smart-pointer.md"};function o(l,s,c,d,i,r){return p(),a("div",null,s[0]||(s[0]=[e(`<h1 id="smart-pointer" tabindex="-1">smart pointer <a class="header-anchor" href="#smart-pointer" aria-label="Permalink to &quot;smart pointer&quot;">​</a></h1><p>智能指针是一种数据结构，在 Rust 中，它们的主要功能是拥有它们指向的数据。它们还可以拥有其他功能，例如引用计数。</p><p><strong>智能指针的“智能”之处在于它们具有额外的元数据和功能。</strong></p><p>这句话意味着，与传统的裸指针（raw pointers）相比，智能指针不仅仅是一个指向数据的地址。智能指针还包含其他的信息和能力。</p><p><strong>元数据</strong></p><ol><li><strong>引用计数</strong>：例如，在<code>Rc</code>和<code>Arc</code>智能指针中，元数据会记录有多少个所有者共享此数据。这样，当最后一个所有者被丢弃时，数据可以被安全地删除。</li><li><strong>借用标志</strong>：例如，在<code>RefCell</code>中，元数据会跟踪当前的借用状态，例如是否有活跃的可变借用，以及有多少个不可变借用。</li></ol><p>额外的元数据: 这可以包括如引用计数（在Rc和Arc中）的信息，表示有多少个所有者共享这个数据。</p><p><strong>功能</strong></p><p>**智能指针通常有一些内置的方法和功能。**例如：</p><p>Drop特性：当智能指针离开其作用域时，Drop特性允许它执行一些清理工作，例如释放内存。 Deref特性：使得智能指针可以被解引用，从而让它们表现得像常规的引用。 RefCell的borrow和borrow_mut方法：这些方法允许在运行时借用或可变借用内部数据，提供动态的借用检查。 因此，当我们说智能指针是“智能”的时候，我们是指它们不仅仅是一个简单的指针，它们还有其他的附加信息和功能，这些信息和功能使得它们在内存管理、数据共享和并发中更为强大和灵活。</p><p>Rust 中的智能指针通常通过结构体来实现，并实现了<code>Deref</code>和<code>Drop</code>特性。</p><p><code>Deref</code>特性允许智能指针实例表现得像常规引用，使得可以读写指针指向的数据。<code>Drop</code>特性则允许我们定制当智能指针离开作用域时的代码，常常用于释放资源。</p><p><strong>&amp;T 和 &amp;mut T</strong></p><ol><li><p><strong>&amp;T (不可变引用)</strong></p><ul><li>当你只想读取数据，而不想修改它时，使用不可变引用。</li><li>你可以同时拥有多个不可变引用指向相同的数据。</li><li>不可变引用和可变引用不能同时存在。</li></ul></li><li><p><strong>&amp;mut T (可变引用)</strong></p><ul><li>当你想修改引用的数据时，使用可变引用。</li><li>在同一时间，对于给定的数据，只能存在一个可变引用。这避免了数据竞争。</li><li>如果你有一个可变引用，你不能同时拥有任何不可变引用。</li></ul><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>   let mut data = 5;</span></span>
<span class="line"><span>​</span></span>
<span class="line"><span>   // 创建一个不可变引用</span></span>
<span class="line"><span>   let ref1 = &amp;data;</span></span>
<span class="line"><span>   let ref2 = &amp;data; // 这是允许的，因为它们都是不可变引用</span></span>
<span class="line"><span>​</span></span>
<span class="line"><span>   // 创建一个可变引用</span></span>
<span class="line"><span>   // let mut_ref = &amp;mut data; // 这将会导致编译错误，因为我们已经有了不可变引用</span></span>
<span class="line"><span>​</span></span>
<span class="line"><span>   // 释放不可变引用</span></span>
<span class="line"><span>   drop(ref1);</span></span>
<span class="line"><span>   drop(ref2);</span></span>
<span class="line"><span>​</span></span>
<span class="line"><span>   // 现在我们可以创建一个可变引用</span></span>
<span class="line"><span>   let mut_ref = &amp;mut data;</span></span>
<span class="line"><span>   *mut_ref += 1; // 使用可变引用修改数据</span></span></code></pre></div><p><strong>即“在任何时候，要么只有一个可变引用，要么只有多个不可变引用”，以确保引用安全性和避免数据竞争</strong></p><p><strong>Box&lt; T&gt;</strong></p><p><code>Box&lt;T&gt;</code> 是 Rust 中的一个智能指针，它允许你在堆上分配值。它是一个包含堆分配数据的指针的结构。当 <code>Box&lt;T&gt;</code> 离开其作用域时，其析构函数被调用，堆上的数据以及箱子本身所使用的堆内存都被清理，确保没有内存泄漏。</p><p>以下是关于 <code>Box&lt;T&gt;</code> 的一些关键点：</p><ol><li><strong>堆上分配</strong>：<code>Box&lt;T&gt;</code> 提供了一个简单的方法在堆上分配数据。例如，大型数据结构或者那些实现时不知道大小的类型，如递归数据结构。</li><li><strong>所有权</strong>：<code>Box&lt;T&gt;</code> 提供了所有权语义，这意味着它遵循 Rust 的所有权规则，例如数据移动的概念。</li><li><strong>用于抽象</strong>：<code>Box&lt;T&gt;</code> 常常与特性对象一起使用，为不同类型提供统一的接口。</li><li><strong>递归数据结构</strong>：例如，定义递归的链表或树时，<code>Box&lt;T&gt;</code> 是必要的，因为在 Rust 中，类型的大小在编译时必须是已知的，而 <code>Box</code> 允许我们绕过这一限制。</li></ol><p>以下是使用 <code>Box&lt;T&gt;</code> 的一些示例：</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>// 在堆上分配一个整数</span></span>
<span class="line"><span>let b = Box::new(5);</span></span>
<span class="line"><span>println!(&quot;b = {}&quot;, *b);</span></span>
<span class="line"><span>​</span></span>
<span class="line"><span>// 定义递归数据结构</span></span>
<span class="line"><span>enum List&lt;T&gt; {</span></span>
<span class="line"><span>    Cons(T, Box&lt;List&lt;T&gt;&gt;),</span></span>
<span class="line"><span>    Nil,</span></span>
<span class="line"><span>}</span></span>
<span class="line"><span>​</span></span>
<span class="line"><span>let list: List&lt;i32&gt; = List::Cons(1, Box::new(List::Cons(2, Box::new(List::Nil))));</span></span></code></pre></div><p>在上述示例中，<code>Box</code> 允许我们在堆上分配一个整数，并定义一个递归的 <code>List</code> 枚举。没有 <code>Box</code>，我们无法定义这种递归数据结构，因为 Rust 需要在编译时知道 <code>List&lt;T&gt;</code> 的确切大小，而递归定义意味着大小是未知的。使用 <code>Box</code> 解决了这个问题，因为 <code>Box</code> 的大小是固定的（它是一个指针大小）。</p></li></ol><p><strong>std::rc::Rc&lt; T&gt;</strong></p><p>std::rc::Rc&lt;T&gt; 是 Rust 中的一个引用计数智能指针，用于跟踪一个值的引用数量。当引用数量降至零时，值及其所有相关资源都会被清理。Rc stands for &quot;Reference Counting&quot;.</p><p>以下是关于 std::rc::Rc&lt;T&gt; 的一些关键点：</p><p>共享所有权：Rc&lt;T&gt; 允许多个指针同时拥有同一个数据的所有权。每当一个新的引用到某个数据被创建时，引用计数会增加，每当一个引用被丢弃时，引用计数会减少。</p><p>只在单线程环境中使用：Rc&lt;T&gt; 不是线程安全的。如果需要在并发或并行情境中使用引用计数智能指针，应考虑使用 std::sync::Arc&lt;T&gt;。</p><p>避免循环引用：如果两个 Rc&lt;T&gt; 值相互引用，将形成循环，这会导致内存泄漏。为解决这个问题，Rust 提供了 std::rc::Weak&lt;T&gt;。</p><p>以下是使用 std::rc::Rc&lt;T&gt; 的示例：</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>use std::rc::Rc;</span></span>
<span class="line"><span>​</span></span>
<span class="line"><span>let foo = Rc::new(vec![1.0, 2.0, 3.0]);</span></span>
<span class="line"><span>​</span></span>
<span class="line"><span>// 增加两个引用，使引用计数增加到 3</span></span>
<span class="line"><span>let a = foo.clone();</span></span>
<span class="line"><span>let b = foo.clone();</span></span>
<span class="line"><span>​</span></span>
<span class="line"><span>// 当 \`foo\`、\`a\` 和 \`b\` 都离开作用域后，数据会被清理</span></span></code></pre></div><p>在上述示例中，我们创建了一个 Rc 指向一个向量。然后，我们调用了 clone 来创建两个额外的引用。这不会深度复制数据，而只是增加引用计数。当所有三个 Rc 指针离开作用域并被丢弃时，它们所指向的数据也会被丢弃，因为此时引用计数将为零。</p><p><strong>std::rc::Weak&lt;T&gt;</strong></p><p><code>std::rc::Weak&lt;T&gt;</code> 是 Rust 中的一个弱引用智能指针，它与 <code>std::rc::Rc&lt;T&gt;</code> （一个强引用计数智能指针）一同工作。<code>Weak&lt;T&gt;</code> 并不会增加引用计数，所以它不会阻止其所指向的值被丢弃。这种特性使得 <code>Weak&lt;T&gt;</code> 特别有用于避免循环引用，这在使用 <code>Rc&lt;T&gt;</code> 时可能会出现。</p><p>以下是关于 <code>std::rc::Weak&lt;T&gt;</code> 的一些关键点：</p><ol><li><strong>避免循环引用</strong>：例如，如果你有两个 <code>Rc&lt;T&gt;</code> 值，它们互相引用，它们之间会形成一个循环，导致内存泄露。但如果其中一个是 <code>Weak&lt;T&gt;</code>，这就避免了循环，因为弱引用不会增加引用计数。</li><li><strong>不会阻止值被丢弃</strong>：<code>Weak&lt;T&gt;</code> 本身并不会阻止其引用的值被丢弃。只有当对应的 <code>Rc&lt;T&gt;</code> 存在时，<code>Weak&lt;T&gt;</code> 才能够被升级为一个有效的 <code>Rc&lt;T&gt;</code>。</li><li><strong>升级</strong>：可以尝试使用 <code>Weak&lt;T&gt;</code> 的 <code>upgrade</code> 方法将其升级为一个 <code>Option&lt;Rc&lt;T&gt;&gt;</code>。如果对应的 <code>Rc&lt;T&gt;</code> 还存在，<code>upgrade</code> 会返回 <code>Some</code>，否则返回 <code>None</code>。</li></ol><p>以下是一个使用 <code>std::rc::Rc&lt;T&gt;</code> 和 <code>std::rc::Weak&lt;T&gt;</code> 的示例，展示了如何避免循环引用：</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>use std::rc::{Rc, Weak};</span></span>
<span class="line"><span>​</span></span>
<span class="line"><span>struct Node {</span></span>
<span class="line"><span>    value: i32,</span></span>
<span class="line"><span>    next: Option&lt;Rc&lt;Node&gt;&gt;,</span></span>
<span class="line"><span>    prev: Option&lt;Weak&lt;Node&gt;&gt;,</span></span>
<span class="line"><span>}</span></span>
<span class="line"><span>​</span></span>
<span class="line"><span>fn main() {</span></span>
<span class="line"><span>    let first = Rc::new(Node {</span></span>
<span class="line"><span>        value: 1,</span></span>
<span class="line"><span>        next: None,</span></span>
<span class="line"><span>        prev: None,</span></span>
<span class="line"><span>    });</span></span>
<span class="line"><span>​</span></span>
<span class="line"><span>    let second = Rc::new(Node {</span></span>
<span class="line"><span>        value: 2,</span></span>
<span class="line"><span>        next: None,</span></span>
<span class="line"><span>        prev: Some(Rc::downgrade(&amp;first)),</span></span>
<span class="line"><span>    });</span></span>
<span class="line"><span>​</span></span>
<span class="line"><span>    // 这里我们没有创建循环引用，因为 \`first\` 的 \`prev\` 是一个 \`Weak&lt;Node&gt;\`。</span></span>
<span class="line"><span>}</span></span></code></pre></div><p>在上述示例中，我们创建了两个 <code>Node</code>。<code>first</code> 节点引用 <code>second</code> 作为下一个节点，但使用 <code>Weak&lt;T&gt;</code> 引用作为前一个节点，从而避免了循环引用。</p><p>总的来说，<code>std::rc::Weak&lt;T&gt;</code> 是在共享所有权情境下，用于避免循环引用和内存泄露的一个工具。</p><p><strong>强引用和弱引用</strong></p><p>强引用和弱引用是两种不同的引用类型，它们在内存管理和垃圾收集上的行为有所不同。这两种引用主要在某些编程语言中使用，尤其是那些支持引用计数的语言（如 Rust、Objective-C）。下面是它们之间的主要区别和特点：</p><p><strong>强引用（Strong Reference）:</strong></p><ol><li><strong>引用计数增加</strong>：当你创建一个强引用，它所指向的对象的引用计数会增加。</li><li><strong>防止对象被释放</strong>：只要对象有至少一个强引用，它就不会被释放。</li><li><strong>常见使用</strong>：在大多数情况下，当你创建一个引用或指针，你实际上是创建一个强引用。</li><li><strong>可能导致的问题</strong>：强引用可能导致循环引用，从而导致内存泄漏。例如，如果两个对象相互强引用，即使没有其他引用它们，它们也不会被释放。</li></ol><p><strong>弱引用（Weak Reference）:</strong></p><ol><li><strong>引用计数不变</strong>：当你创建一个弱引用，它所指向的对象的引用计数不会增加。</li><li><strong>不会阻止对象被释放</strong>：即使存在弱引用，对象仍然可以被释放。</li><li><strong>“安全”引用</strong>：弱引用可以被视为一种“安全”引用，因为它不会导致循环引用和内存泄漏。</li><li><strong>需要“升级”</strong>：为了访问弱引用所指向的对象，通常需要将其“升级”为强引用。如果该对象已经被释放，则升级会失败。</li></ol><p>在 Rust 中，<code>std::rc::Rc&lt;T&gt;</code> 和 <code>std::rc::Weak&lt;T&gt;</code> 分别代表强引用和弱引用。使用 <code>Rc::clone</code> 会增加强引用计数，而 <code>Rc::downgrade</code> 会创建一个弱引用。要从弱引用访问对象，你需要调用 <code>Weak::upgrade</code>，这会尝试返回一个 <code>Option&lt;Rc&lt;T&gt;&gt;</code></p><p>&quot;计数&quot; 是指 &quot;引用计数&quot;（Reference Counting）。引用计数是一种内存管理技术，用于跟踪一个对象在内存中被多少个引用所指向。每当一个新的引用指向对象时，计数增加；每当一个引用不再指向对象或被销毁时，计数减少。当计数降至0时，意味着没有任何引用再指向该对象，因此该对象可以被安全地回收。</p><p>在 Rust 的 <code>std::rc::Rc&lt;T&gt;</code>（强引用）和 <code>std::rc::Weak&lt;T&gt;</code>（弱引用）中：</p><ol><li><strong>强引用计数</strong>：<code>Rc&lt;T&gt;</code> 实现了强引用计数。每当你使用 <code>Rc::clone</code> 创建一个新的 <code>Rc&lt;T&gt;</code> 引用时，强引用计数会增加。当 <code>Rc&lt;T&gt;</code> 引用离开其作用域并被丢弃时，强引用计数会减少。当强引用计数降至0时，该对象会被销毁并释放其内存。</li><li><strong>弱引用计数</strong>：<code>Weak&lt;T&gt;</code> 不会影响强引用计数，但它有自己的计数器，叫做弱引用计数。弱引用主要用于避免循环引用，它允许引用一个对象，但不阻止该对象被销毁。当所有的强引用都被丢弃，对象会被销毁，即使还有弱引用存在。如果尝试通过弱引用访问对象，你需要“升级”它，这可能会成功（返回 <code>Some(Rc&lt;T&gt;)</code>）或失败（返回 <code>None</code>），取决于相关对象是否仍然存在。</li></ol><p><strong>std::cell::Cell&lt;T&gt;和std::cell::RefCell&lt;T&gt;</strong></p><p>std::cell::Cell&lt;T&gt; 和 std::cell::RefCell&lt;T&gt; 都是 Rust 的标准库中提供的用于实现内部可变性的类型，但它们适用于不同的场景并有不同的行为。让我们来比较它们：</p><p><strong>Cell&lt;T&gt;:</strong></p><p>值语义: Cell&lt;T&gt; 适用于那些实现了 Copy trait 的类型。这意味着你不能直接获取到存储在 Cell 中的值的引用，而是获取其值的副本。 不可借用为引用: 你不能从 Cell&lt;T&gt; 获取一个可变或不可变引用，但你可以使用 set 和 get 方法对其进行读写。 用途: 对于小的 Copy 类型，例如 i32、bool 等，Cell 是一个很好的选择。</p><p><strong>RefCell&lt;T&gt;:</strong></p><p>引用语义: RefCell&lt;T&gt; 允许你在运行时借用其内部数据为可变或不可变引用。但这是在运行时进行检查的，如果你违反了借用规则（例如，同时持有多个可变引用），程序会 panic。 动态借用检查: 当你尝试借用数据时，RefCell 会在运行时检查是否违反了 Rust 的借用规则，如果违反了，它会 panic。 用途: 当你需要在逻辑上保持不可变性，但在某些情况下需要修改内部数据时，RefCell 是一个不错的选择。它通常与 Rc 一起使用来创建多个拥有者的可变数据。 总之，这两个类型都提供了一种绕过 Rust 的借用检查器的方法，但要确保在运行时遵循借用规则。Cell&lt;T&gt; 更适用于简单的 Copy 类型，而 RefCell&lt;T&gt; 提供了更为灵活的内部可变性，但带有运行时的借用检查成本。</p><p><strong>*const T 和 *mut T</strong></p><p>*const T 和 *mut T 是 Rust 中的原生指针类型。它们提供了一个对底层内存的不安全、未经检查的引用。这两种指针类型通常在与 C 代码互操作或编写低级代码时使用。</p><p>*<strong>const T:</strong></p><p>不可变原生指针：它表示一个指向某种类型 T 的常量指针。这意味着你理论上不应该通过这个指针修改所指向的数据。 只读：虽然这是一个原生指针，但从其语义上，你应该把它当作一个只读指针。 *<strong>mut T:</strong></p><p>可变原生指针：它表示一个指向某种类型 T 的可变指针，允许你修改所指向的数据。 读写：你可以通过这个指针读取和修改数据。 需要注意的是，尽管有 const 和 mut 两种类型，但在底层它们都是普通的指针，区别只在于它们的语义。Rust 的安全保证并不适用于这些指针，因此在使用它们时必须非常小心。通常，你只在需要绕过 Rust 的安全保证时才使用它们，并且需要确保手动管理相关的所有安全性问题。</p><p>此外，与 Rust 中的引用（例如 &amp;T 和 &amp;mut T）不同，原生指针不遵循 Rust 的借用规则。这意味着你可以拥有多个可变原生指针指向同一块内存，或者同时拥有可变和不可变原生指针，而编译器不会阻止这种行为。因此，使用原生指针时必须非常小心，确保不违反这些规则，否则可能会导致未定义的行为。</p><p><strong>自动解引用</strong></p><p>自动解引用（Deref Coercion）是 Rust 语言的一个功能，它允许 Rust 在调用方法时自动为指针或智能指针解引用。</p><p>当你调用一个对象上的方法时，Rust 会自动为你解引用（或连续解引用）该对象，直到找到一个实现了该方法的类型。这一过程是由 Rust 中的 <code>Deref</code> 特性和 <code>DerefMut</code> 特性支持的。</p><p>举个例子来说，如果我们有一个 <code>&amp;Box&lt;T&gt;</code> 类型的引用，我们可以直接在其上调用 <code>T</code> 类型的方法，而无需手动解引用它。这是因为 <code>Box&lt;T&gt;</code> 实现了 <code>Deref</code> 特性，返回一个 <code>&amp;T</code> 类型的引用。</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>struct MyStruct {</span></span>
<span class="line"><span>    value: i32,</span></span>
<span class="line"><span>}</span></span>
<span class="line"><span>​</span></span>
<span class="line"><span>impl MyStruct {</span></span>
<span class="line"><span>    fn my_method(&amp;self) {</span></span>
<span class="line"><span>        println!(&quot;Called my_method with value: {}&quot;, self.value);</span></span>
<span class="line"><span>    }</span></span>
<span class="line"><span>}</span></span>
<span class="line"><span>​</span></span>
<span class="line"><span>fn main() {</span></span>
<span class="line"><span>    let my_box = Box::new(MyStruct { value: 42 });</span></span>
<span class="line"><span>    // 这里我们在 Box&lt;MyStruct&gt; 上直接调用了 my_method，而没有手动解引用</span></span>
<span class="line"><span>    my_box.my_method();</span></span>
<span class="line"><span>}</span></span></code></pre></div><p>在上面的例子中，Rust 为我们自动解引用了 <code>my_box</code> 从 <code>Box&lt;MyStruct&gt;</code> 到 <code>MyStruct</code>，因此我们可以直接调用 <code>my_method</code>。如果没有自动解引用，我们需要这样写：<code>(*my_box).my_method();</code>。</p><p>这种自动解引用特别有用，因为它使得与智能指针（如 <code>Box</code>, <code>Rc</code>, <code>Arc</code> 等）或其他实现了 <code>Deref</code>/<code>DerefMut</code> 特性的类型一起工作变得更为简洁。</p><p>\\</p>`,61)]))}const T=n(t,[["render",o]]);export{u as __pageData,T as default};
